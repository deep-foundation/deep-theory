(*
Определения Теории Связей:
Последовательность идентификаторов кортежей: L ⊆ ℕ₀
Множество кортежей идентификаторов длины n ∈ ℕ₀: Tn ⊆ Lⁿ.
Множество всех ассоциаций: A = L × Tn.
Семейство функций: ∪_n {netⁿ | n ∈ ℕ₀} ⊆ A
Здесь ∪ обозначает объединение всех функций в семействе {netⁿ},
 ⊆ обозначает 'это подмножество',
 а A - множество всех ассоциаций.
 Это говорит о том, что все упорядоченные пары, полученные от функций netⁿ, являются подмножеством A.
Ассоциативная сеть кортежей длины n из семейства функций {netⁿ},
 netⁿ : L → Tn отображает идентификатор l из множества L в кортеж идентификаторов длины n,
 который принадлежит множеству Tn.
 'n' в netⁿ указывает на то, что функция возвращает кортежи, содержащие n идентификаторов. 
Ассоциативная сеть дуплетов: net² : L → T₂.
Ассоциативная сеть вложенных упорядоченных пар: net : L → P,
 где P = {(∅,∅) | (l,∅) | (l1,l2), l, l1, l2 ∈ L} - это множество вложенных упорядоченных пар,
 которое состоит из пустых пар, пар, содержащих только один элемент, и пар, содержащих два элемента.
Дополнительные пояснения:
Кортеж длины n ∈ ℕ₀ можно представить как вложенные упорядоченные пары.
Идентификатор кортежа - уникальный идентификатор, каждый из которых связан с определенным кортежем.
Кортеж идентификаторов - это кортеж, состоящий из нуля или нескольких идентификаторов кортежей,
 где количество индексов соответствует количеству элементов кортежа.
Ассоциация - это упорядоченная пара, состоящая из идентификатора кортежа и кортежа идентификаторов. Эта структура служит для отображения между идентификаторами и кортежами.
Пустой кортеж представлен пустым множеством: () представлено как ∅.
*)

(* 
  `anet` - это индуктивный тип в Coq для представления ассоциативной сети (асеть, anet):
  Он может быть использован для представления различных структур данных и вычислений,
  включая натуральные числа, списки, деревья, графы и ассоциативные сети.

- Натуральные числа: конструкторы `B` и `L` повторяют стандартную конструкцию натуральных чисел в Coq.
  При этом `B` представляет ноль, а `L` увеличивает число на единицу.

- Фрактальные списки или древовидные структуры: конструктор `A` принимает два значения типа `anet` и ассоциирует их вместе,
  создавая вложенную структуру. Таким образом, `anet` может представлять древовидные структуры,
  где `A` используется для создания узлов дерева, а `B` и `L` используются для представления листьев.

- Фрактальные структуры: благодаря рекурсивной природе `anet`, он может представлять фрактальные структуры.
  Каждый узел, созданный с помощью `A`, может содержать другие значения `anet`,
  которые сами могут быть деревьями, созданными с помощью `A`. Таким образом,
  `anet` может представлять собой отношение самоподобия и вложенности, характерное для фракталов.

- В контексте графа, например, `A` мог бы быть использован для представления ребра между двумя вершинами.

Обратите внимание, что поведение и свойства `anet` будут зависеть от конкретных сценариев использования и интерпретации,
которую вы присваиваете каждому из конструкторов `B`, `L`, `A`.
*)
Inductive anet : Type :=
  | B : anet
  | L : anet -> anet
  | A : anet -> anet -> anet. 


(* 
  Функция `init_anet0` - это функция инициализации списка,
  которая создает чистую ассоциативную сеть нульплетов заданной длины,
  т.е. создает пустой список заданной длины. 
*)
Fixpoint init_anet0 (n : nat) : anet :=
match n with 
| 0 => B
| S n' => L (init_anet0 n')
end.


(* 
  Функция `init_anet1` - это функция инициализации списка, которая создает чистую ассоциативную сеть синглетов заданной длины. 
  Каждый индекс списка представлен как `B` (то есть число `0`).
*)
Fixpoint init_anet1 (n : nat) : anet :=
match n with 
| 0 => B
| S n' => A B (init_anet1 n')
end.


(* 
  Функция `init_anet2` - это функция инициализации списка, которая создает чистую ассоциативную дуплет заданной длины. 
  Каждый элемент списка представлен как `A B B` (то есть дуплет из пары `0`).
*)
Fixpoint init_anet2 (n : nat) : anet :=
match n with 
| 0 => B
| S n' => A (A B B) (init_anet2 n')
end.


(* 
  Функция init_anet_with создаёт anet длины n, где каждый элемент представлен как a.
  Если n равно 0, функция вернёт B. В противном случае, она создаст anet,
  который начинается с a и рекурсивно включает остальные элементы, полученные вызовом init_anet_with.
*)
Fixpoint init_anet_with (n : nat) (a : anet) : anet :=
match n with 
| 0 => B
| S n' => A a (init_anet_with n' a)
end.


(* 
  Функция `get_dim` вычисляет размерность или "вложенность" `anet`.
  Обратите внимание, что это всего лишь одна из возможных метрик "глубины" или "размера" `anet`, 
  и конкретный выбор функции будет зависеть от вашего приложения или модели.
*)
Fixpoint get_dim (a : anet) : nat :=
match a with
| B => 0
| L a' => 0
| A a' _ => 1 + get_dim a'
end.


(* 
  Функция `get_lenght` вычисляет глубину `anet` или длину списка воспринимая его как последовательность аналогичную nat.
*)
Fixpoint get_lenght (a : anet) : nat :=
match a with
| B => 0
| L a1 => 1 + (get_lenght a1)
| A _ a2 => 1 + (get_lenght a2)
end.

(* Создаем некоторые списки для тестирования *)
Definition zero_dim_0  := init_anet0 0.
Definition three_dim_0 := init_anet0 3.
Definition three_dim_1 := init_anet1 3.
Definition three_dim_2 := init_anet2 3.
Definition custom_list := init_anet_with 3 three_dim_2.

(* Тесты для функции get_dim *)
Compute get_dim zero_dim_0.     (* Результат должен быть: 0 *)
Compute get_dim three_dim_0.    (* Результат должен быть: 0 *)
Compute get_dim three_dim_1.    (* Результат должен быть: 1 *)
Compute get_dim three_dim_2.    (* Результат должен быть: 2 *)
Compute get_dim custom_list.    (* Результат должен быть: 3 *)

(* Тесты для функции get_lenght *)
Compute get_lenght zero_dim_0.  (* Результат должен быть: 0 *)
Compute get_lenght three_dim_0. (* Результат должен быть: 3 (потому что список имеет 3 элемента) *)
Compute get_lenght three_dim_1. (* Результат должен быть: 3 (потому что список имеет 3 элемента) *)
Compute get_lenght three_dim_2. (* Результат должен быть: 3 (потому что список имеет 3 элемента) *)
Compute get_lenght custom_list. (* Результат должен быть: 3 *)


