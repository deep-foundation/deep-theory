(*
  Определения Теории связей в терминах Теории множеств:

1. Идентификатор вектора - уникальный идентификатор, каждый из которых связан с определенным вектором.
  Последовательность идентификаторов векторов: L ⊆ ℕ₀.

2. Вектор идентификаторов: это вектор, состоящий из нуля или нескольких идентификаторов векторов,
  где количество индексов соответствует количеству элементов вектора.
  Множество всех векторов идентификаторов длины n ∈ ℕ₀: Vn = Lⁿ.
  Декартова степень Lⁿ всегда даст вектор длины n, так как все его компоненты будут одного и того же типа L.
  Другими словами, Lⁿ представляет собой множество всех возможных n-элементных векторов, где каждый элемент вектора принадлежит множеству L.

3. Ассоциация - это упорядоченная пара, состоящая из идентификатора вектора и вектора идентификаторов.
  Эта структура служит для отображения между идентификаторами и векторами или точками в пространстве.
  Множество всех ассоциаций: A = L × Vn.

4. Семейство функций: ∪_f {anetvⁿ | n ∈ ℕ₀} ⊆ A.
  Здесь ∪ обозначает объединение всех функций в семействе {anetvⁿ},
  ⊆ обозначает 'это подмножество', а A - множество всех ассоциаций.
  Это говорит о том, что все упорядоченные пары, полученные от функций anetvⁿ, являются подмножеством A.

5. Ассоциативная сеть векторов длины n (или n-мерная асеть) из семейства функций {anetvⁿ},
  anetvⁿ : L → Vn отображает идентификатор l из множества L в кортеж идентификаторов длины n,
  который принадлежит множеству Vn, фактически идентифицирует точки в n-мерном пространстве.
  'n' в anetvⁿ указывает на то, что функция возвращает вектора, содержащие n идентификаторов. 


6. Дуплет идентификаторов (упорядоченная пара или двухмерный вектор): D = L²
  Это множество всех упорядоченных пар (L, L), или вторая декартова степень L.

7. Ассоциативная сеть дуплетов (или двумерная асеть): anetd : L → L².

8. Пустой вектор представлен пустым множеством: () представлено как ∅.
  Вектор длины n ∈ ℕ₀ можно представить как вложенные упорядоченные пары.

9. Ассоциативная сеть вложенных упорядоченных пар: anetl : L → NP,
  где NP = {(∅,∅) | (l,np), l ∈ L, np ∈ NP} - это множество вложенных упорядоченных пар,
  которое состоит из пустых пар, и пар содержащих один или более элементов.
*)

Require Import Coq.Lists.List.

Check (nil : list nat). (* Пустой вектор *)
(* nil : list nat *)

Check (1 :: nil). (* Вектор с одним элементом [1] *)
(* cons 1 nil : list nat *)

Check (1 :: 2 :: 3 :: nil). (* Вектор [1, 2, 3] *)
(* 1 :: 2 :: 3 :: nil : list nat *)

Compute nth 2 (1 :: 2 :: 3 :: 4 :: 5 :: 6 :: nil) 0. (* Получение элемента по индексу из вектора [1, 2, 3, 4] *)
(* nth 2 [1; 2; 3; 4] 0 : nat *)


(* 
  `anum` - это индуктивный тип в Coq для представления ассоциативного числа, который является расширением чисел Пеано:
  Они могут быть использован для представления различных структур данных и вычислений,
  включая натуральные числа, списки, деревья, графы и ассоциативные сети кортежей.

- Натуральные числа: конструкторы `B` и `L` повторяют стандартную конструкцию натуральных чисел в Coq.
  При этом `B` представляет ноль, а `L` увеличивает число на единицу.

- Фрактальные списки или древовидные структуры: конструктор `A` принимает два значения типа `anum` и ассоциирует их вместе,
  создавая вложенную структуру. Таким образом, `anum` может представлять древовидные структуры,
  где `A` используется для создания узлов дерева, а `B` и `L` используются для представления листьев.

- Фрактальные структуры: благодаря рекурсивной природе `anum`, он может представлять фрактальные структуры.
  Каждый узел, созданный с помощью `A`, может содержать другие значения `anum`,
  которые сами могут быть деревьями, созданными с помощью `A`. Таким образом,
  `anum` может представлять собой отношение самоподобия и вложенности, характерное для фракталов.

- В контексте графа, например, `A` мог бы быть использован для представления ребра между двумя вершинами.

Обратите внимание, что поведение и свойства `anum` будут зависеть от конкретных сценариев использования и интерпретации,
которую вы присваиваете каждому из конструкторов `B`, `L`, `A`.
*)
Inductive anum : Type :=
  | B : anum
  | L : anum -> anum
  | A : anum -> anum -> anum. 


(* 
  Функция `init_anet0` - это функция инициализации списка,
  которая создает чистую ассоциативную сеть нульплетов заданной длины,
  т.е. создает пустой список заданной длины. 
*)
Fixpoint init_anet0 (n : nat) : anum :=
match n with 
| 0 => B
| S n' => L (init_anet0 n')
end.


(* 
  Функция `init_anet1` - это функция инициализации списка, которая создает чистую ассоциативную сеть синглетов заданной длины. 
  Каждый индекс списка представлен как `B` (то есть число `0`).
*)
Fixpoint init_anet1 (n : nat) : anum :=
match n with 
| 0 => B
| S n' => A B (init_anet1 n')
end.


(* 
  Функция `init_anet2` - это функция инициализации списка, которая создает чистую ассоциативную дуплет заданной длины. 
  Каждый элемент списка представлен как `A B B` (то есть дуплет из пары `0`).
*)
Fixpoint init_anet2 (n : nat) : anum :=
match n with 
| 0 => B
| S n' => A (A B B) (init_anet2 n')
end.


(* 
  Функция init_anet_with создаёт anum длины n, где каждый элемент представлен как a.
  Если n равно 0, функция вернёт B. В противном случае, она создаст anum,
  который начинается с a и рекурсивно включает остальные элементы, полученные вызовом init_anet_with.
*)
Fixpoint init_anet_with (n : nat) (a : anum) : anum :=
match n with 
| 0 => B
| S n' => A a (init_anet_with n' a)
end.


(* 
  Функция `get_dim` вычисляет размерность или "вложенность" `anum`.
  Обратите внимание, что это всего лишь одна из возможных метрик "глубины" или "размера" `anum`, 
  и конкретный выбор функции будет зависеть от вашего приложения или модели.
*)
Fixpoint get_dim (a : anum) : nat :=
match a with
| B => 0
| L a' => 0
| A a' _ => 1 + get_dim a'
end.


(* 
  Функция `get_size` вычисляет глубину `anum` или длину списка воспринимая его как последовательность аналогичную nat.
*)
Fixpoint get_size (a : anum) : nat :=
match a with
| B => 0
| L a1 => S (get_size a1)
| A _ a2 => S (get_size a2)
end.


(* 
  Функция `concat` принимает два значения типа `anum`,
  которые представляют собой списки, и возвращает их
  конкатенацию – один список, который начинается
  с элементов первого списка и продолжается элементами второго.
  В случае пустых списков функцию можно использовать как арифметическое сложение длин.
 *)
Fixpoint concat (a1 a2 : anum) : anum :=
  match a1 with
  | B => a2
  | L B => A B a2
  | L a1' => L (concat a1' a2)
  | A head1 tail1 => A head1 (concat tail1 a2)
  end.

From Coq Require Import Lia.

Lemma length_concat_correct : forall a1 a2, 
  get_size (concat a1 a2) = get_size a1 + get_size a2.
Proof. 
  induction a1; intros; simpl. 
  - reflexivity.
  - destruct a1;
    simpl; rewrite IHa1; auto with arith.
  - rewrite IHa1_2; auto with arith. 
Qed.


Fixpoint map_anet (f : anum -> anum) (a : anum) :=
  match a with
  | B => B
  | L _ => f a
  | A head tail => A (f head) (map_anet f tail)
  end.

Fixpoint anet_pairs (a1 a2 : anum) : anum :=
  match a1 with
  | B => B
  | L _ => map_anet (fun x => A a1 x) a2
  | A head1 tail1 => A (anet_pairs head1 a2) (anet_pairs tail1 a2)
  end.


(* Создаем некоторые списки для тестирования *)
Definition zero_dim_0  := init_anet0 0.
Definition three_dim_0 := init_anet0 3.
Definition three_dim_1 := init_anet1 3.
Definition three_dim_2 := init_anet2 3.
Definition custom_list := init_anet_with 3 three_dim_2.

(* Тесты для функции get_dim *)
Compute get_dim zero_dim_0.     (* Результат должен быть: 0 *)
Compute get_dim three_dim_0.    (* Результат должен быть: 0 *)
Compute get_dim three_dim_1.    (* Результат должен быть: 1 *)
Compute get_dim three_dim_2.    (* Результат должен быть: 2 *)
Compute get_dim custom_list.    (* Результат должен быть: 3 *)

(* Тесты для функции get_size *)
Compute get_size zero_dim_0.  (* Результат должен быть: 0 *)
Compute get_size three_dim_0. (* Результат должен быть: 3 (потому что список имеет 3 элемента) *)
Compute get_size three_dim_1. (* Результат должен быть: 3 (потому что список имеет 3 элемента) *)
Compute get_size three_dim_2. (* Результат должен быть: 3 (потому что список имеет 3 элемента) *)
Compute get_size custom_list. (* Результат должен быть: 3 *)

(* Создаём списки для тестирования *)
Definition list1 := (A (L B) (A (L B) B)).
Definition list2 := (A (L (L B)) (A (L (L B)) B)).

Definition nat_0 := init_anet0 0.
Definition nat_1 := init_anet0 1.
Definition nat_123 := init_anet0 123.
Definition nat_277 := init_anet0 277.

(* Запускаем тесты *)
Compute (concat list1 list2).
Compute get_size (concat nat_0 nat_277).
Compute get_size (concat nat_1 nat_277).
Compute get_size (concat nat_123 nat_0).
Compute get_size (concat nat_123 nat_1).
Compute get_size (concat nat_123 nat_277).





